## Functions and libraries

```{r}
source("../Scripts/Fun_Preprocessing.R")
source("../Scripts/Fun_Composition.R")
load(file = "../Preprocessed/geneInfo.rda")
load("../Preprocessed/exonicLength.rda")
```
## Lists

```{r}
# to hold the dataset-level Seurat objects
obj <- list() # to store data from...
obj$VL <- list() # Velmeshev 2019
obj$NG <- list() # Nagy 2020
obj$CA <- list() # Hodge 2019
obj$TS <- list() # Tasic 2018
obj$LK <- list() # Lake 2018
```


## Key parameters
```{r}
# for seurat preprocessing
min.cells <- 3 # during the initial load, a gene is excluded if in < 3 cells 
min.features <- 200 # during the initial load, a barcode is excluded < 200 features are expressed
min.depth <- 1000 # a barcode is excluded if nCount_RNA < this value
max.depth.percentile <- 0.995 # a barcode is excluded if nCount_RNA > this percentile within the dataset
max.mito <- 5

# preprocessing options
downsample <- FALSE
downsample.n <- NA; if (downsample) downsample.n <- NA
use.SCTransform <- FALSE

# mixture options
nMix <- 500 # number of cells to aggregate per mixture
nReps <- 100 # number of mixtures to simulate
```


## Functions

```{r}
## Function for downsampling the dataset to a set number of barcodes
  downsample.fun <- function(x, n = downsample.n) {
    if (ncol(x) <= downsample.n) {
      print("No downsampling performed (Reason: number of cells in dataset is already less than or equal to the downsampling number)")
    } else {
      sample <- sample(colnames(x), size = n, replace = FALSE)
      x <- subset(x, cells = sample)  
    }
    return(x)
  }

## General function for preprocessing sn data (normalise, filters, and scales)
  get.max.depth <- function(x) {
    max.depth <- quantile(x@meta.data$nCount_RNA, probs = max.depth.percentile)
  }
  
  preprocess.fun <- function(x, run.downsample = downsample, SCTransform = use.SCTransform, max.depth = max.depth) {
    # quantify mitochondrial reads
    x[["percent.mito"]] <- PercentageFeatureSet(object = x, pattern = "^MT-")
    
    # filter to remove outlier nuclei: 
    
    x <- subset(x = x, subset = (nCount_RNA > min.depth) & (nCount_RNA < max.depth) & (percent.mito < max.mito))
    
    # downsample
    if (run.downsample) { x <- downsample.fun(x) }
    
    # normalise expression levels
    x <- NormalizeData(object = x, normalization.method = "LogNormalize", scale.factor = 10000) # standard parameters for Seurat
  
    # find variable genes (i.e. features)
    x <- FindVariableFeatures(object = x, selection.method = "vst", nfeatures = 2000)
    
    
    # further normalisation
    if (use.SCTransform) {
      x <- SCTransform(object = x, vars.to.regress = c("nCount_RNA", "percent.mito")) 
    }
    
    # output
    return(x)
  } 
  
  # ## Function for brief UMAP visualisation. x must be the output of preprocess.fun(x)
  # UMAP.fun <- function(x, dims = 30) {
  #   x <- ScaleData(object = x, vars.to.regress = c("nCount_RNA", "percent.mito")) 
  #   x <- RunPCA(x, npcs = dims)
  #   x <- FindNeighbors(object = x, dims = 1:dims) 
  #   x <- FindClusters(object = x, resolution = 1) # "We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets"
  #   x <- RunUMAP(object = x, dims = 1:dims)
  # }
  
   ## Function for integration!
  run.integration <- function(x = obj, SCTransform = use.SCTransform) {
    if (SCTransform) {
      int.features <- SelectIntegrationFeatures(object.list = x, nfeatures = 2000)
      int <- PrepSCTIntegration(object.list = x, anchor.features = int.features)
      int <- FindIntegrationAnchors(object.list = int, normalization.method = "SCT", anchor.features = int.features) 
      int <- IntegrateData(anchorset = int, normalization.method = "SCT")
    } else {
      int <- FindIntegrationAnchors(object.list = x)
      int <- IntegrateData(anchorset = int)
    }
    
    return(int)
  }
  
   ## Function to remove features
  filter.features <- function(x, search = "^MT-|^RPS|^RPL") {
    keep <- grep(pattern = search, rownames(x@assays$RNA@counts), invert = TRUE) # ribosomal and mitochondrial genes  
    x <- subset(x, features = keep)
    return(x)
  }
  
```


## CA

```{r}
## Read in
  dat <- read.csv("../Raw/human_MTG_gene_expression_matrices_2018-06-14/human_MTG_2018-06-14_exon-matrix.csv") 
  
  # add gene symbol
  meta <- read.csv("../Raw/human_MTG_gene_expression_matrices_2018-06-14/human_MTG_2018-06-14_genes-rows.csv")
  dat <- dat[,-1] # remove an annotation column
  rownames(dat) <- meta$gene
  
  # create Seurat object
  obj$CA <- CreateSeuratObject(counts = dat,
                                min.cells = round(ncol(dat) / 100),
                                min.features = min.features,
                                project = "HCA")
  
  # augment metadata
  meta <- read.csv("../Raw/human_MTG_gene_expression_matrices_2018-06-14/human_MTG_2018-06-14_samples-columns.csv")
  rownames(meta) <- meta$sample_name
  meta <- meta[colnames(obj$CA),] 
  
  obj$CA$Individual <- meta$donor
  obj$CA$orig.celltype <- meta$cluster
  
## Remove cells with no class
  keep <- which(!(obj$CA$orig.celltype == "no class"))
  obj$CA <- subset(obj$CA, cells = keep)
  
## Preprocess
  max.depth <- get.max.depth(obj$CA)
  obj$CA <- preprocess.fun(obj$CA, max.depth = max.depth)
  
## Remove all (9) endothelial cells
  obj$CA <- subset(obj$CA, cells = grep("Endo", obj$CA$orig.celltype, invert = TRUE))
```
## VL
```{r}
dat <- Read10X("../Raw/Velmeshev2019/rawMatrix/")
obj$VL <- CreateSeuratObject(counts = dat,
                          min.cells = round(ncol(dat) / 100),
                          min.features = min.features,
                          project = "Velmeshev")
rm(dat)
```

```{r}
## Annotate
  meta <- read.table("Raw/Velmeshev2019/meta.tsv", sep = "\t", header = TRUE)
  m <- match(colnames(obj$VL), meta$cell)
  
  obj$VL$orig.celltype <- meta$cluster[m]
  obj$VL$Region <- meta$region[m]
  obj$VL$Disorder <- meta$diagnosis[m]
  obj$VL$orig.ident <- paste0("Vel_", substr(meta$cell[m], start = 1, stop = 16))
  obj$VL$Individual <- meta$individual[m]

## Quick filtering: restrict to PFC control samples
  keep <- which(obj$VL$Region == "PFC" & obj$VL$Disorder == "Control") # from ~105K to  ~30K nuclei
  obj$VL <- subset(obj$VL, cells = keep)
  
## Preprocess and normalise
  max.depth <- get.max.depth(obj$VL)
  obj$VL <- preprocess.fun(obj$VL, max.depth = max.depth)
```

